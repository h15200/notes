ORM - Object Relational Mapping - unlike native drivers through npm, usually more powerful
Ex - In mongo, the native mongoDB api is native, and mongoose is an ORM

Prisma is a GraphQL ORM
Unlike mongoose or sequalize, it is database agnostic! Can use any database
Prisma works well with sql db

Setting up postgres DB on Heroku
Go to heroku.com and make a new app called somethign like “aomori-prisma-dev-server”
Go to overview tab, pick add-on heroku postgres, get free dev tier
Click on db, go to settings, db credentials to see connection details

GUI for postgres- pgAdmin
Open, start new server
Name it the same as the db on heroku
Go to the connection tab
Add host, port
Database in Heroku = Maintenance Databse in pgAdmin
User = Username
Password - check box

Docker - a container to set up dependencies and apps cross platform through virtual machine

Prisma
npm i -g prisma
prisma init <nameOfProject> (usually just ‘prisma’)
No existing data (probably), postgres

Enter all info from the heroku credentials page
Must say Yes to use SSL for heroku postgres

Rename .prisma file to .graphql for syntax highlighting
If you do, change the prisma.yml file endpoint to the new .graphql

docker-compose up -d

Wait a minute after docker-compose as it’s known to fail if prism is deployed too soon after!

PRISMA DEPLOY must be written in the terminal level where the yml lives! It is often one level deeper than your project itself

prisma deploy

Now you can get the graphql playground at localhost:4466
And another GUI for the database at localhost:4466/\_admin

These are now connected to the heroku postgres database!
Prism comes with pre defined schema queries, mutations, and subscriptions

Test connection
Create user in playground
Check pgAdmin - expand your database, default, table, user
Right click user, view/edit data all rows

datamodel.graphql will act like as schema

New syntax @unique, @id, @createdAt, @updatedAt built-in

prisma deploy will update the models if you change in datamodel.graphql

In prisma.yml, add

generate:

- generator: javascript-client
  output: src/generated/prisma-client
  // generated/prisma-client is usually the conventional folder for this

In terminal, prisma generate

Make a file, prisma.js inside src, and import the entire file to index.js.

npm i prisma-client-lib

Inside prisma.js

    import { prisma } from ‘./generated/prisma-client’   // index.js not necessary

const main = async () => {

const fragment = `fragment usersWithPosts on User { name posts { id title body } }`
try {
const allUsers = await prisma.Users().\$fragment(fragment)

// \$fragment determines the returned fields
// JSON.stringify so that the post field is not [Object] and is defined

console.log (JSON.stringify(allUsers, undefined, 4)

} catch (err) {
console.log(err)
}

Prisma Client - exists. (use \$exists, and the lowercase of the model)

// inside an async func

    const userExists = await prisma.$exists.user( { id: something} ) // returns true or false promise

// when you try to delete a user that has a relation to comment or post, it will often throw an error because once the post/comment is created, it has a mandatory field, ‘author’ which becomes null and invalid once the user is deleted. To modify this behavior,

In datamodel.graphQL, you have two ways of customizing relations

SET_NULL and CASCADE
SET_NULL is default. When you delete a user, the author field in post will be set to null, which can not because user!, so that’s causing the error. Changing to cascade will solve this

@relation(name: ‘RelationName’, setDelete: CASCADE)

Make sure name: ‘RelationName’ matches BOTH ways on two models

Resolvers in graphQL will automatically resolve promises, so you can do something like

return prisma.users() and it will work

When connecting to client, prisma client does not need to bind to the info arg from the resolvers.

Now prisma backend is connected via docker server and localhost:4466, but that direct connection to server should be closed off to just the node (localhost:4000) interface. To do that, add a prisma secret to the yml file and prisma deploy again.

If you want to continue working with the server, add an http header on the playground
{
{authorization: Bearer <token>}
}

The token can be generated by running prisma token in terminal

Use bcrypt and jwt to authenticate in a helper function.

To lockdown specific queries INSIDE a resolver, use fragments

You can use formulas from prisma generated models with prisma graphql-import . graphQL yoga already has this, so you can just start in the graphQL file with

# import <thing> from ‘path’

DEPLOYING:

Prisma cloud
Heroku

Make a new server and database

Look at the heroku server credentials, connect pgAdmin (or another db gui)

To Deploy, first change the prisma.yml file (which dictates what happens when you run prisma deploy)

Make a new dir called config
Make dev.env, prod.env with key value pairs

              In Dev,
             PRISMA_ENDPOINT=http://localhost:4466

    In prisma.yml

       endpoint: ${env:PRISMA_ENDPOINT}

    In terminal, prisma deploy -e ../config/dev.env   // path to point to the file and -e flag


    For prod.env, let prisma inject the url
                  To do that, prisma login   - grant permission
                 Leave prod.env EMPTY
             run prisma deploy -e ../config/prod.env
              Now it will spit out the url for the production - copy and put it in prod.env, delete the one in prisma.yml and uncomment the endpoint

See the Mead PDF for details
